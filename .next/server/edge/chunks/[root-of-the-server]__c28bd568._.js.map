{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 21, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/lib/auth.ts"],"sourcesContent":["import { SignJWT, jwtVerify, type JWTPayload } from \"jose\";\n\n// Load the JWT secret from environment variables\nconst JWT_SECRET = process.env.JWT_SECRET;\n\n// Throw an error if no secret is defined (stops server from starting without one)\nif (!JWT_SECRET) {\n    throw new Error(\"JWT_SECRET is not defined in environment variables\");\n}\n\n// Convert the secret string to Uint8Array (required by jose)\nconst encoder = new TextEncoder();\nconst secret = encoder.encode(JWT_SECRET);\n\n/**\n * Signs a JWT with the given payload and expiration.\n * @param payload - The data to embed in the token (e.g. userId, role)\n * @param expiresIn - Expiry time as a string (e.g. \"15m\", \"1h\", \"1d\", or seconds)\n * @returns A Promise resolving to a JWT string\n */\nexport async function signToken(\n    payload: JWTPayload,\n    expiresIn: string = \"15m\"\n): Promise<string> {\n    // Get current time in seconds\n    const now = Math.floor(Date.now() / 1000);\n\n    // Calculate expiration time in seconds\n    let exp: number;\n    if (expiresIn.endsWith(\"m\")) {\n        exp = now + parseInt(expiresIn) * 60; // minutes\n    } else if (expiresIn.endsWith(\"h\")) {\n        exp = now + parseInt(expiresIn) * 60 * 60; // hours\n    } else if (expiresIn.endsWith(\"d\")) {\n        exp = now + parseInt(expiresIn) * 60 * 60 * 24; // days\n    } else {\n        exp = now + parseInt(expiresIn); // fallback: treat as seconds\n    }\n\n    // Create, sign, and return the JWT\n    return await new SignJWT(payload)\n        .setProtectedHeader({ alg: \"HS256\" }) // Set algorithm\n        .setIssuedAt(now)                     // Set issue time\n        .setExpirationTime(exp)               // Set expiration time\n        .sign(secret);                        // Sign with secret\n}\n\n/**\n * Verifies a JWT and returns the decoded payload if valid.\n * @param token - The JWT string to verify\n * @returns A Promise resolving to the payload (if valid)\n * @throws If the token is expired or invalid\n */\nexport async function verifyToken(token: string): Promise<JWTPayload> {\n    // jose throws if invalid; otherwise returns decoded payload\n    const { payload } = await jwtVerify(token, secret);\n    return payload;\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;;AAEA,iDAAiD;AACjD,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU;AAEzC,kFAAkF;AAClF,IAAI,CAAC,YAAY;IACb,MAAM,IAAI,MAAM;AACpB;AAEA,6DAA6D;AAC7D,MAAM,UAAU,IAAI;AACpB,MAAM,SAAS,QAAQ,MAAM,CAAC;AAQvB,eAAe,UAClB,OAAmB,EACnB,YAAoB,KAAK;IAEzB,8BAA8B;IAC9B,MAAM,MAAM,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK;IAEpC,uCAAuC;IACvC,IAAI;IACJ,IAAI,UAAU,QAAQ,CAAC,MAAM;QACzB,MAAM,MAAM,SAAS,aAAa,IAAI,UAAU;IACpD,OAAO,IAAI,UAAU,QAAQ,CAAC,MAAM;QAChC,MAAM,MAAM,SAAS,aAAa,KAAK,IAAI,QAAQ;IACvD,OAAO,IAAI,UAAU,QAAQ,CAAC,MAAM;QAChC,MAAM,MAAM,SAAS,aAAa,KAAK,KAAK,IAAI,OAAO;IAC3D,OAAO;QACH,MAAM,MAAM,SAAS,YAAY,6BAA6B;IAClE;IAEA,mCAAmC;IACnC,OAAO,MAAM,IAAI,6JAAA,CAAA,UAAO,CAAC,SACpB,kBAAkB,CAAC;QAAE,KAAK;IAAQ,GAAG,gBAAgB;KACrD,WAAW,CAAC,KAAyB,iBAAiB;KACtD,iBAAiB,CAAC,KAAmB,sBAAsB;KAC3D,IAAI,CAAC,SAAgC,mBAAmB;AACjE;AAQO,eAAe,YAAY,KAAa;IAC3C,4DAA4D;IAC5D,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,CAAA,GAAA,+JAAA,CAAA,YAAS,AAAD,EAAE,OAAO;IAC3C,OAAO;AACX"}},
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/middleware.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport type { NextRequest } from \"next/server\";\nimport { verifyToken } from \"@/lib/auth\";\n\n// Protects routes by checking for a valid JWT token in cookies\nexport async function middleware(request: NextRequest) {\n  // Extract the JWT token from cookies\n  const token = request.cookies.get(\"auth_token\")?.value;\n\n  // Log the JWT_SECRET and token for debugging purposes (to be removed in production)\n  console.log(\"JWT_SECRET in middleware:\", process.env.JWT_SECRET);\n  console.log(\"Token in middleware:\", token);\n\n  // If no token is found, redirect to sign-in page\n  if (!token) {\n    return NextResponse.redirect(new URL(\"/sign-in\", request.url));\n  }\n\n  try {\n    // Verify the token using jose (async function)\n    await verifyToken(token);\n    // If token is valid, proceed to the requested page\n    return NextResponse.next();\n  } catch (e) {\n    // If token verification fails, log the error and redirect to sign-in page\n    console.log(\"Token verification failed in middleware:\", e);\n    return NextResponse.redirect(new URL(\"/sign-in\", request.url));\n  }\n}\n\n// Protect the dashboard and its subpages\nexport const config = {\n  matcher: [\"/dashboard/:path*\"],\n};\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAEA;;;AAGO,eAAe,WAAW,OAAoB;IACnD,qCAAqC;IACrC,MAAM,QAAQ,QAAQ,OAAO,CAAC,GAAG,CAAC,eAAe;IAEjD,oFAAoF;IACpF,QAAQ,GAAG,CAAC,6BAA6B,QAAQ,GAAG,CAAC,UAAU;IAC/D,QAAQ,GAAG,CAAC,wBAAwB;IAEpC,iDAAiD;IACjD,IAAI,CAAC,OAAO;QACV,OAAO,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,YAAY,QAAQ,GAAG;IAC9D;IAEA,IAAI;QACF,+CAA+C;QAC/C,MAAM,CAAA,GAAA,0HAAA,CAAA,cAAW,AAAD,EAAE;QAClB,mDAAmD;QACnD,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI;IAC1B,EAAE,OAAO,GAAG;QACV,0EAA0E;QAC1E,QAAQ,GAAG,CAAC,4CAA4C;QACxD,OAAO,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,YAAY,QAAQ,GAAG;IAC9D;AACF;AAGO,MAAM,SAAS;IACpB,SAAS;QAAC;KAAoB;AAChC"}}]
}