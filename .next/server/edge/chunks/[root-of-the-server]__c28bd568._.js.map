{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 21, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/lib/auth.ts"],"sourcesContent":["import { SignJWT, jwtVerify, type JWTPayload } from \"jose\";\n\nconst JWT_SECRET = process.env.JWT_SECRET;\n\nif (!JWT_SECRET) {\n    throw new Error(\"JWT_SECRET is not defined in environment variables\");\n}\n\n// Helper to convert the secret to Uint8Array for jose\nconst encoder = new TextEncoder();\nconst secret = encoder.encode(JWT_SECRET);\n\n/**\n * Sign a JWT with the given payload and expiration (default 15m)\n */\nexport async function signToken(\n    payload: JWTPayload,\n    expiresIn: string = \"15m\"\n): Promise<string> {\n    // Calculate expiration in seconds\n    const now = Math.floor(Date.now() / 1000);\n    let exp: number;\n    if (expiresIn.endsWith(\"m\")) {\n        exp = now + parseInt(expiresIn) * 60;\n    } else if (expiresIn.endsWith(\"h\")) {\n        exp = now + parseInt(expiresIn) * 60 * 60;\n    } else if (expiresIn.endsWith(\"d\")) {\n        exp = now + parseInt(expiresIn) * 60 * 60 * 24;\n    } else {\n        // fallback: treat as seconds\n        exp = now + parseInt(expiresIn);\n    }\n\n    return await new SignJWT(payload)\n        .setProtectedHeader({ alg: \"HS256\" })\n        .setIssuedAt(now)\n        .setExpirationTime(exp)\n        .sign(secret);\n}\n\n/**\n * Verify a JWT and return the payload if valid\n */\nexport async function verifyToken(token: string): Promise<JWTPayload> {\n    const { payload } = await jwtVerify(token, secret);\n    return payload;\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;;AAEA,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU;AAEzC,IAAI,CAAC,YAAY;IACb,MAAM,IAAI,MAAM;AACpB;AAEA,sDAAsD;AACtD,MAAM,UAAU,IAAI;AACpB,MAAM,SAAS,QAAQ,MAAM,CAAC;AAKvB,eAAe,UAClB,OAAmB,EACnB,YAAoB,KAAK;IAEzB,kCAAkC;IAClC,MAAM,MAAM,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK;IACpC,IAAI;IACJ,IAAI,UAAU,QAAQ,CAAC,MAAM;QACzB,MAAM,MAAM,SAAS,aAAa;IACtC,OAAO,IAAI,UAAU,QAAQ,CAAC,MAAM;QAChC,MAAM,MAAM,SAAS,aAAa,KAAK;IAC3C,OAAO,IAAI,UAAU,QAAQ,CAAC,MAAM;QAChC,MAAM,MAAM,SAAS,aAAa,KAAK,KAAK;IAChD,OAAO;QACH,6BAA6B;QAC7B,MAAM,MAAM,SAAS;IACzB;IAEA,OAAO,MAAM,IAAI,6JAAA,CAAA,UAAO,CAAC,SACpB,kBAAkB,CAAC;QAAE,KAAK;IAAQ,GAClC,WAAW,CAAC,KACZ,iBAAiB,CAAC,KAClB,IAAI,CAAC;AACd;AAKO,eAAe,YAAY,KAAa;IAC3C,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,CAAA,GAAA,+JAAA,CAAA,YAAS,AAAD,EAAE,OAAO;IAC3C,OAAO;AACX"}},
    {"offset": {"line": 61, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/middleware.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport type { NextRequest } from \"next/server\";\nimport { verifyToken } from \"@/lib/auth\";\n\nexport async function middleware(request: NextRequest) {\n  const token = request.cookies.get(\"auth_token\")?.value;\n\n  console.log(\"JWT_SECRET in middleware:\", process.env.JWT_SECRET);\n  console.log(\"Token in middleware:\", token);\n\n  if (!token) {\n    return NextResponse.redirect(new URL(\"/sign-in\", request.url));\n  }\n\n  try {\n    await verifyToken(token);\n    return NextResponse.next();\n  } catch (e) {\n    console.log(\"Token verification failed in middleware:\", e);\n    return NextResponse.redirect(new URL(\"/sign-in\", request.url));\n  }\n}\n\nexport const config = {\n  matcher: [\"/dashboard/:path*\"],  // protect dashboard and subroutes\n};\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAEA;;;AAEO,eAAe,WAAW,OAAoB;IACnD,MAAM,QAAQ,QAAQ,OAAO,CAAC,GAAG,CAAC,eAAe;IAEjD,QAAQ,GAAG,CAAC,6BAA6B,QAAQ,GAAG,CAAC,UAAU;IAC/D,QAAQ,GAAG,CAAC,wBAAwB;IAEpC,IAAI,CAAC,OAAO;QACV,OAAO,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,YAAY,QAAQ,GAAG;IAC9D;IAEA,IAAI;QACF,MAAM,CAAA,GAAA,0HAAA,CAAA,cAAW,AAAD,EAAE;QAClB,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI;IAC1B,EAAE,OAAO,GAAG;QACV,QAAQ,GAAG,CAAC,4CAA4C;QACxD,OAAO,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,YAAY,QAAQ,GAAG;IAC9D;AACF;AAEO,MAAM,SAAS;IACpB,SAAS;QAAC;KAAoB;AAChC"}}]
}