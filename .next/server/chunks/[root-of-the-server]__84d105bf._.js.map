{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 66, "column": 0}, "map": {"version":3,"sources":["file:///Users/koji/Desktop/auth/src/lib/auth.ts"],"sourcesContent":["import { SignJWT, jwtVerify, type JWTPayload } from \"jose\";\n\n// Load the JWT secret from environment variables\nconst JWT_SECRET = process.env.JWT_SECRET;\n\n// Throw an error if no secret is defined (stops server from starting without one)\nif (!JWT_SECRET) {\n    throw new Error(\"JWT_SECRET is not defined in environment variables\");\n}\n\n// Convert the secret string to Uint8Array (required by jose)\nconst encoder = new TextEncoder();\nconst secret = encoder.encode(JWT_SECRET);\n\n/**\n * Signs a JWT with the given payload and expiration.\n * @param payload - The data to embed in the token (e.g. userId, role)\n * @param expiresIn - Expiry time as a string (e.g. \"15m\", \"1h\", \"1d\", or seconds)\n * @returns A Promise resolving to a JWT string\n */\nexport async function signToken(\n    payload: JWTPayload,\n    expiresIn: string = \"15m\"\n): Promise<string> {\n    // Get current time in seconds\n    const now = Math.floor(Date.now() / 1000);\n\n    // Calculate expiration time in seconds\n    let exp: number;\n    if (expiresIn.endsWith(\"m\")) {\n        exp = now + parseInt(expiresIn) * 60; // minutes\n    } else if (expiresIn.endsWith(\"h\")) {\n        exp = now + parseInt(expiresIn) * 60 * 60; // hours\n    } else if (expiresIn.endsWith(\"d\")) {\n        exp = now + parseInt(expiresIn) * 60 * 60 * 24; // days\n    } else {\n        exp = now + parseInt(expiresIn); // fallback: treat as seconds\n    }\n\n    // Create, sign, and return the JWT\n    return await new SignJWT(payload)\n        .setProtectedHeader({ alg: \"HS256\" }) // Set algorithm\n        .setIssuedAt(now)                     // Set issue time\n        .setExpirationTime(exp)               // Set expiration time\n        .sign(secret);                        // Sign with secret\n}\n\n/**\n * Verifies a JWT and returns the decoded payload if valid.\n * @param token - The JWT string to verify\n * @returns A Promise resolving to the payload (if valid)\n * @throws If the token is expired or invalid\n */\nexport async function verifyToken(token: string): Promise<JWTPayload> {\n    // jose throws if invalid; otherwise returns decoded payload\n    const { payload } = await jwtVerify(token, secret);\n    return payload;\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;;AAEA,iDAAiD;AACjD,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU;AAEzC,kFAAkF;AAClF,IAAI,CAAC,YAAY;IACb,MAAM,IAAI,MAAM;AACpB;AAEA,6DAA6D;AAC7D,MAAM,UAAU,IAAI;AACpB,MAAM,SAAS,QAAQ,MAAM,CAAC;AAQvB,eAAe,UAClB,OAAmB,EACnB,YAAoB,KAAK;IAEzB,8BAA8B;IAC9B,MAAM,MAAM,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK;IAEpC,uCAAuC;IACvC,IAAI;IACJ,IAAI,UAAU,QAAQ,CAAC,MAAM;QACzB,MAAM,MAAM,SAAS,aAAa,IAAI,UAAU;IACpD,OAAO,IAAI,UAAU,QAAQ,CAAC,MAAM;QAChC,MAAM,MAAM,SAAS,aAAa,KAAK,IAAI,QAAQ;IACvD,OAAO,IAAI,UAAU,QAAQ,CAAC,MAAM;QAChC,MAAM,MAAM,SAAS,aAAa,KAAK,KAAK,IAAI,OAAO;IAC3D,OAAO;QACH,MAAM,MAAM,SAAS,YAAY,6BAA6B;IAClE;IAEA,mCAAmC;IACnC,OAAO,MAAM,IAAI,uJAAA,CAAA,UAAO,CAAC,SACpB,kBAAkB,CAAC;QAAE,KAAK;IAAQ,GAAG,gBAAgB;KACrD,WAAW,CAAC,KAAyB,iBAAiB;KACtD,iBAAiB,CAAC,KAAmB,sBAAsB;KAC3D,IAAI,CAAC,SAAgC,mBAAmB;AACjE;AAQO,eAAe,YAAY,KAAa;IAC3C,4DAA4D;IAC5D,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,CAAA,GAAA,yJAAA,CAAA,YAAS,AAAD,EAAE,OAAO;IAC3C,OAAO;AACX","debugId":null}},
    {"offset": {"line": 121, "column": 0}, "map": {"version":3,"sources":["file:///Users/koji/Desktop/auth/src/lib/bcrypt.ts"],"sourcesContent":["import bcrypt from \"bcrypt\";\n\n/**\n * Hashes a plaintext password using bcrypt.\n * @param password - The plaintext password to hash\n * @returns A Promise resolving to the hashed password string\n */\nexport async function hashPassword(password: string) {\n    // 10 salt rounds is a good default for bcrypt security & speed\n    return bcrypt.hash(password, 10);\n}\n\n/**\n * Compares a plaintext password to a bcrypt hash.\n * @param plainPassword - The user's input (plaintext)\n * @param hashedPassword - The stored bcrypt hash\n * @returns A Promise resolving to true if match, false otherwise\n */\nexport async function comparePassword(\n    plainPassword: string,\n    hashedPassword: string\n) {\n    // Returns true if passwords match, false otherwise\n    return bcrypt.compare(plainPassword, hashedPassword);\n}\n"],"names":[],"mappings":";;;;AAAA;;AAOO,eAAe,aAAa,QAAgB;IAC/C,+DAA+D;IAC/D,OAAO,qGAAA,CAAA,UAAM,CAAC,IAAI,CAAC,UAAU;AACjC;AAQO,eAAe,gBAClB,aAAqB,EACrB,cAAsB;IAEtB,mDAAmD;IACnD,OAAO,qGAAA,CAAA,UAAM,CAAC,OAAO,CAAC,eAAe;AACzC","debugId":null}},
    {"offset": {"line": 243, "column": 0}, "map": {"version":3,"sources":["file:///Users/koji/Desktop/auth/src/db/schema.ts"],"sourcesContent":["import { mysqlTable, serial, varchar, text } from \"drizzle-orm/mysql-core\";\n\n// Define the \"users\" table schema for Drizzle ORM\nexport const users = mysqlTable(\"users\", {\n    // Auto-incrementing integer primary key for each user\n    id: serial(\"id\").primaryKey(),\n\n    // Unique username for login (max 255 characters, required)\n    username: varchar(\"username\", { length: 255 }).notNull().unique(),\n\n    // Hashed password (stored as text, required)\n    passwordHash: text(\"passwordHash\").notNull(),\n\n    // Role of the user (e.g. \"user\", \"admin\"; default is \"user\")\n    role: varchar(\"role\", { length: 50 }).notNull().default(\"user\"),\n});\n"],"names":[],"mappings":";;;AAAA;AAAA;AAAA;AAAA;;AAGO,MAAM,QAAQ,CAAA,GAAA,0JAAA,CAAA,aAAU,AAAD,EAAE,SAAS;IACrC,sDAAsD;IACtD,IAAI,CAAA,GAAA,sKAAA,CAAA,SAAM,AAAD,EAAE,MAAM,UAAU;IAE3B,2DAA2D;IAC3D,UAAU,CAAA,GAAA,uKAAA,CAAA,UAAO,AAAD,EAAE,YAAY;QAAE,QAAQ;IAAI,GAAG,OAAO,GAAG,MAAM;IAE/D,6CAA6C;IAC7C,cAAc,CAAA,GAAA,oKAAA,CAAA,OAAI,AAAD,EAAE,gBAAgB,OAAO;IAE1C,6DAA6D;IAC7D,MAAM,CAAA,GAAA,uKAAA,CAAA,UAAO,AAAD,EAAE,QAAQ;QAAE,QAAQ;IAAG,GAAG,OAAO,GAAG,OAAO,CAAC;AAC5D","debugId":null}},
    {"offset": {"line": 269, "column": 0}, "map": {"version":3,"sources":["file:///Users/koji/Desktop/auth/src/app/api/auth/sign-in/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { cookies } from \"next/headers\";\nimport { signToken } from \"@/lib/auth\";\nimport { comparePassword } from \"@/lib/bcrypt\";\nimport { drizzle } from \"drizzle-orm/mysql2\";\nimport mysql from \"mysql2/promise\";\nimport { users } from \"@/db/schema\";\nimport { eq } from \"drizzle-orm\";\n\n// Handles POST requests for user sign-in\nexport async function POST(req: Request) {\n    let connection;\n    try {\n        // Parse the request body for username and password\n        const { username, password } = await req.json();\n\n        // Connect to the MySQL database\n        connection = await mysql.createConnection({\n            host: process.env.DATABASE_HOST!,\n            port: Number(process.env.DATABASE_PORT!),\n            user: process.env.DATABASE_USER!,\n            password: process.env.DATABASE_PASSWORD!,\n            database: process.env.DATABASE_NAME!,\n        });\n\n        // Initialize Drizzle ORM with the MySQL connection\n        const db = drizzle(connection);\n\n        // Check if the user exists in the database\n        const [user] = await db\n            .select()\n            .from(users)\n            .where(eq(users.username, username))\n            .limit(1);\n\n        // If user is not found, return an error response\n        if (!user) {\n            return NextResponse.json(\n                { success: false, message: \"Invalid username or password\" },\n                { status: 401 }\n            );\n        }\n\n        // Compare the provided password with the stored hashed password\n        const passwordMatch = await comparePassword(password, user.passwordHash);\n\n        // If the password does not match, return an error response\n        if (!passwordMatch) {\n            return NextResponse.json(\n                { success: false, message: \"Invalid username or password\" },\n                { status: 401 }\n            );\n        }\n\n        // If login is successful, sign a JWT token with the user's ID and role\n        const token = await signToken({ userId: user.id, role: user.role });\n\n        // Set the JWT token in an httpOnly cookie\n        const cookieStore = await cookies();\n        cookieStore.set(\"auth_token\", token, {\n            httpOnly: true,\n            secure: process.env.NODE_ENV === \"production\", // Use secure cookies in production\n            sameSite: \"strict\",\n            path: \"/\",\n            maxAge: 60 * 15, // Cookie expires in 15 minutes\n        });\n\n        // Return a success response with the token\n        return NextResponse.json({ success: true, message: \"Login successful\" });\n    } catch (error) {\n        // Error logs for debugging\n        console.error(\"Login error:\", error);\n        return NextResponse.json(\n            { success: false, message: \"Internal server error\" },\n            { status: 500 }\n        );\n    } finally {\n        // Always close the database connection if it was opened\n        if (connection) await connection.end();\n    }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAGO,eAAe,KAAK,GAAY;IACnC,IAAI;IACJ,IAAI;QACA,mDAAmD;QACnD,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,GAAG,MAAM,IAAI,IAAI;QAE7C,gCAAgC;QAChC,aAAa,MAAM,mIAAA,CAAA,UAAK,CAAC,gBAAgB,CAAC;YACtC,MAAM,QAAQ,GAAG,CAAC,aAAa;YAC/B,MAAM,OAAO,QAAQ,GAAG,CAAC,aAAa;YACtC,MAAM,QAAQ,GAAG,CAAC,aAAa;YAC/B,UAAU,QAAQ,GAAG,CAAC,iBAAiB;YACvC,UAAU,QAAQ,GAAG,CAAC,aAAa;QACvC;QAEA,mDAAmD;QACnD,MAAM,KAAK,CAAA,GAAA,oKAAA,CAAA,UAAO,AAAD,EAAE;QAEnB,2CAA2C;QAC3C,MAAM,CAAC,KAAK,GAAG,MAAM,GAChB,MAAM,GACN,IAAI,CAAC,qHAAA,CAAA,QAAK,EACV,KAAK,CAAC,CAAA,GAAA,oKAAA,CAAA,KAAE,AAAD,EAAE,qHAAA,CAAA,QAAK,CAAC,QAAQ,EAAE,WACzB,KAAK,CAAC;QAEX,iDAAiD;QACjD,IAAI,CAAC,MAAM;YACP,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACpB;gBAAE,SAAS;gBAAO,SAAS;YAA+B,GAC1D;gBAAE,QAAQ;YAAI;QAEtB;QAEA,gEAAgE;QAChE,MAAM,gBAAgB,MAAM,CAAA,GAAA,sHAAA,CAAA,kBAAe,AAAD,EAAE,UAAU,KAAK,YAAY;QAEvE,2DAA2D;QAC3D,IAAI,CAAC,eAAe;YAChB,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACpB;gBAAE,SAAS;gBAAO,SAAS;YAA+B,GAC1D;gBAAE,QAAQ;YAAI;QAEtB;QAEA,uEAAuE;QACvE,MAAM,QAAQ,MAAM,CAAA,GAAA,oHAAA,CAAA,YAAS,AAAD,EAAE;YAAE,QAAQ,KAAK,EAAE;YAAE,MAAM,KAAK,IAAI;QAAC;QAEjE,0CAA0C;QAC1C,MAAM,cAAc,MAAM,CAAA,GAAA,iIAAA,CAAA,UAAO,AAAD;QAChC,YAAY,GAAG,CAAC,cAAc,OAAO;YACjC,UAAU;YACV,QAAQ,oDAAyB;YACjC,UAAU;YACV,MAAM;YACN,QAAQ,KAAK;QACjB;QAEA,2CAA2C;QAC3C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,SAAS;YAAM,SAAS;QAAmB;IAC1E,EAAE,OAAO,OAAO;QACZ,2BAA2B;QAC3B,QAAQ,KAAK,CAAC,gBAAgB;QAC9B,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACpB;YAAE,SAAS;YAAO,SAAS;QAAwB,GACnD;YAAE,QAAQ;QAAI;IAEtB,SAAU;QACN,wDAAwD;QACxD,IAAI,YAAY,MAAM,WAAW,GAAG;IACxC;AACJ","debugId":null}}]
}